Name        SPI Interface for the 6502;
PartNo      65SPI;
Date        08/15/2020;
Revision    5;
Designer    Daryl Rictor;
Company     none;
Assembly    65SPI;
Location    1;
Device      f1504ispplcc44;
Format      j;

/*////////////////////////////////////////////////////////////////////////////////
//                                                                               //
//  This program and its associated documentation are provided for your personal //
//  use only and appear here exclusively by permission of the copyright holder.  //
//  Please contact the copyright holder before re-distributing, re-publishing    //
//  or disseminating this copyrighted work. This code is not GPL or in the       // 
//  public domain. Please respect the author's copyright.                        //
//                                                                               //
//  No waranty, either expressed or implied, are given.  I assume no liability   //
//  for its use in any project or device.                                        //
//                                                                               //
//  Your use of this program indicates your acceptance of all license terms.     //
//  This particular version is freeware as long as these copyright messages are  //
//  left intact.                                                                 //  
//                                                                               //
 ///////////////////////////////////////////////////////////////////////////////*/

/**
 * ATF1504 relevant valid extensions:
 * AP, AR, CE, CK, D, IO, L, LE, OE, T
 */

PROPERTY ATMEL {TDI_PULLUP = ON};       /* Enable internal pull-up on TDI */
PROPERTY ATMEL {TMS_PULLUP = ON};       /* Enable internal pull-up on TMS */
PROPERTY ATMEL {LOGIC_DOUBLING = OFF};  /* Automatically borrow unused Macrocells for complex logic */
PROPERTY ATMEL {CASCADE_LOGIC = ON};    /* */
PROPERTY ATMEL {OUTPUT_FAST = ON};      /* Slow slew rate (which is still quite fast!) */
PROPERTY ATMEL {PIN_KEEP = OFF};        /* Disable the state-keepers on PINs */
PROPERTY ATMEL {PREASSIGN = YES};       /* Allow pin pre-assignment */
PROPERTY ATMEL {SECURITY = OFF};        /* Disable the security fuse */
PROPERTY ATMEL {XOR_SYNTHESIS = OFF};   /* */
PROPERTY ATMEL {POWER_RESET = OFF};     /* Small Power-on Reset Hysteresis */

/*////////////////////////////////////////////////////////////////////////////////
//  "65SPI - 6502/65816 to SPI Master Interface"                                 //
//  Written by Daryl Rictor                                                      //
//  Version 1.5                                                                  //
//  (c) Daryl Rictor 08-15-2020                                                  //
 ///////////////////////////////////////////////////////////////////////////////*/

//
// version 1.5 - Added software reset.
//

/* PINOUT
                              M             E                    
                           V  I       R  G  X                    
                  D  D  D  C  S       E  N  T  R                 
                  6  5  7  C  O       S  D  C  W                 
               ____________________________________              
              /   6  5  4  3  2  1 44 43 42 41 40  \             
         TDI |  7                                39 | PHI2       
          D4 |  8                                38 | TDO        
          D3 |  9                                37 | CS2        
         GND | 10                                36 | CS1        
          D2 | 11                                35 | VCC        
         ss0 | 12            ATF1504             34 | A1         
         TMS | 13          44-Lead PLCC          33 | A0         
          D1 | 14                                32 | TCK        
         VCC | 15                                31 | ss6        
          D0 | 16                                30 | GND        
         ss1 | 17                                29 | ss7        
             |   18 19 20 21 22 23 24 25 26 27 28   |            
              \____________________________________/             
                 s  s  s  s  G  V  M  I  M  M  S                 
                 s  s  s  s  N  C  W  R  R  O  C                 
                 3  4  2  5  D  C  R  Q  D  S  L                 
                                            I  K                 

*/

/* Inputs Pins */
PIN 39 = PHI2;				/* Master clock (14.318MHz) */
PIN 43 = RES;                       	/* Master Reset */
PIN 40 = RW;				/* 6502 R/W PIN */
PIN [33,34] = [A0..1];			/* 6502 Address bus */
PIN 2  = MISO;				/* SPI data in */
PIN 37 = CS2;				/* /CS2 */
PIN 36 = CS1;				/* CS1 */
PIN 41 = EXTC;				/* External SCLK */

/* Address Line Function
  ADDRESS     READ                 WRITE
     0     SPI data in          SPI Data Out
     1     SPI status           SPI control                                                       
     2     SPI slave selects    SPI slave selects                                                       
     3     SPI slave selects    SPI slave selects                                                       
*/

/* 3 State I/O Pins */
PIN [16,14,11,9,8,5,6,4] = [D0..7];			/* 6502 data bus */

/* Output Pins */
PIN 25  = !IRQ;				/* CPU int reg */
PIN 27  = MOSI;				/* SPI data out */
PIN 28  = SCLK;				/* SPI shift clock out */
PIN [12,17,20,18,19,21,31,29] = [ss0..7];			/* SPI slave Select lines */

PIN 26 = MRD;
PIN 24 = MWR;

/* Burried NODES */
NODE    [si0..7];			/* shift in data reg */
NODE    [so0..7];			/* shift out data reg */
NODE    [st0..4];			/* SPI state counter */
NODE    TMO;				/* SPI Enable reg */
NODE    IER;				/* int enable reg */
NODE    BSY;				/* busy flag reg */
NODE    CPOL;				/* Clock polarity reg */
NODE    CPHA;				/* Clock Phase reg */
NODE    INT;				/* FIN/INT register */
NODE    ECE;				/* Ext Clk Enable */
NODE    CKSEL;			/* Int/EXT Clk sel */
NODE	 RMODE;			/* Read only Mode */
NODE    STCLK;			/* State machine clock */
NODE    SRES;				/* Software reset */

/* Memory Read * Write selects */

  !MRD  = PHI2 & RW;
  !MWR  = PHI2 & !RW;

/* CPU IRQ decoder */
  IRQ = !INT & IER;

/* DATA bus buffer timing and source */
  [D0..7] = !A1 & !A0 & [si0..7] #
            !A1 &  A0 & [CPHA,CPOL,ECE,TMO,RMODE,IER,BSY,!INT] #
             A1 & [ss0..7];

  [D0..7].oe = CS1 & !CS2 & PHI2 & RW;
 
/* BSY register operation */
  BSY.d  = 'b'1;
  BSY.ck = CS1 & !CS2 & PHI2 & !A1 & !A0 & (!RW # RMODE);
  BSY.ar = st4 # !RES # SRES;

/* INT register operation */
  INT.d  = 'b'0;
  INT.ck = st4;
  INT.ap = !RES # SRES # (CS1 & !CS2 & PHI2 & !A0 & !A1);

/* SI shift operation */
  [si0..7].ar = !RES # SRES;
  [si0..7].ck = st0 $ CPHA;                      

  si0.d = MISO;
  si1.d = si0;
  si2.d = si1;
  si3.d = si2;
  si4.d = si3;
  si5.d = si4;
  si6.d = si5;
  si7.d = si6;

/* SO shift operation */
  MOSI = so7;
  MOSI.oe = !TMO;
           
  so7.d = so6;
  so6.d = so5;
  so5.d = so4;
  so4.d = so3;
  so3.d = so2;
  so2.d = so1;
  so1.d = so0;
  so0.d = so7;

 [so0..7].ck = (!st0 & !CPHA # st0 & CPHA) & (st1 # st2 # st3 # st4) ;
 
/* SODATA data load (async latch during PHI2 high) */
  so0.ar = !D0 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW # SRES;
  so0.ap =  D0 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW;

  so1.ar = !D1 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW # SRES;
  so1.ap =  D1 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW;

  so2.ar = !D2 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW # SRES;
  so2.ap =  D2 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW;

  so3.ar = !D3 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW # SRES;
  so3.ap =  D3 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW;

  so4.ar = !D4 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW # SRES;
  so4.ap =  D4 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW;

  so5.ar = !D5 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW # SRES;
  so5.ap =  D5 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW;

  so6.ar = !D6 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW # SRES;
  so6.ap =  D6 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW;

  so7.ar = !D7 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW # SRES;
  so7.ap =  D7 & CS1 & !CS2 & PHI2 & !A1 & !A0 & !RW;
                    
/* Slave Select register load */
  ss0.ck = !RES # SRES;
  ss0.d  = 'b'1;
  ss0.ar = !D0 & A1 & CS1 & !CS2 & PHI2 & !RW;
  ss0.ap =  D0 & A1 & CS1 & !CS2 & PHI2 & !RW;

  ss1.ck = !RES # SRES;
  ss1.d  = 'b'1;
  ss1.ar = !D1 & A1 & CS1 & !CS2 & PHI2 & !RW;
  ss1.ap =  D1 & A1 & CS1 & !CS2 & PHI2 & !RW;

  ss2.ck = !RES # SRES;
  ss2.d  = 'b'1;
  ss2.ar = !D2 & A1 & CS1 & !CS2 & PHI2 & !RW;
  ss2.ap =  D2 & A1 & CS1 & !CS2 & PHI2 & !RW;

  ss3.ck = !RES # SRES;
  ss3.d  = 'b'1;
  ss3.ar = !D3 & A1 & CS1 & !CS2 & PHI2 & !RW;
  ss3.ap =  D3 & A1 & CS1 & !CS2 & PHI2 & !RW;

  ss4.ck = !RES # SRES;
  ss4.d  = 'b'1;
  ss4.ar = !D4 & A1 & CS1 & !CS2 & PHI2 & !RW;
  ss4.ap =  D4 & A1 & CS1 & !CS2 & PHI2 & !RW;

  ss5.ck = !RES # SRES;
  ss5.d  = 'b'1;
  ss5.ar = !D5 & A1 & CS1 & !CS2 & PHI2 & !RW;
  ss5.ap =  D5 & A1 & CS1 & !CS2 & PHI2 & !RW;

  ss6.ck = !RES # SRES;
  ss6.d  = 'b'1;
  ss6.ar = !D6 & A1 & CS1 & !CS2 & PHI2 & !RW;
  ss6.ap =  D6 & A1 & CS1 & !CS2 & PHI2 & !RW;

  ss7.ck = !RES # SRES;
  ss7.d  = 'b'1;
  ss7.ar = !D7 & A1 & CS1 & !CS2 & PHI2 & !RW;
  ss7.ap =  D7 & A1 & CS1 & !CS2 & PHI2 & !RW;
                      
/* CTRL register load - bit format = [x,x,IER,RMODE,TMO,ECE,CPOL,CPHA]  */
  IER.ck = !RES;
  IER.d  = 'b'0;
  IER.ar = !D5 & !A1 & A0 & CS1 & !CS2 & PHI2 & !RW;
  IER.ap =  D5 & !A1 & A0 & CS1 & !CS2 & PHI2 & !RW;

  RMODE.ck = !RES;
  RMODE.d  = 'b'0;
  RMODE.ar = !D4 & !A1 & A0 & CS1 & !CS2 & PHI2 & !RW; 
  RMODE.ap =  D4 & !A1 & A0 & CS1 & !CS2 & PHI2 & !RW;

  TMO.ck = !RES;
  TMO.d  = 'b'0;
  TMO.ar = !D3 & !A1 & A0 & CS1 & !CS2 & PHI2 & !RW;
  TMO.ap =  D3 & !A1 & A0 & CS1 & !CS2 & PHI2 & !RW;

  ECE.ck = !RES;
  ECE.d  = 'b'0;
  ECE.ar = !D2 & !A1 & A0 & CS1 & !CS2 & PHI2 & !RW;
  ECE.ap =  D2 & !A1 & A0 & CS1 & !CS2 & PHI2 & !RW;

  CPOL.ck = !RES;
  CPOL.d  = 'b'0;
  CPOL.ar = !D1 & !A1 & A0 & CS1 & !CS2 & PHI2 & !RW;
  CPOL.ap =  D1 & !A1 & A0 & CS1 & !CS2 & PHI2 & !RW;

  CPHA.ck = !RES;
  CPHA.d  = 'b'0;
  CPHA.ar = !D0 & !A1 & A0 & CS1 & !CS2 & PHI2 & !RW;
  CPHA.ap =  D0 & !A1 & A0 & CS1 & !CS2 & PHI2 & !RW;

  SRES.ck = !RES;
  SRES.d  = 'b'0;
  SRES.ar =  !PHI2;  /* !D7 & !A1 & A0 & CS1 & !CS2 & PHI2 & !RW; */
  SRES.ap =  D7 & !A1 & A0 & CS1 & !CS2 & PHI2 & !RW;


/* State machine counter */
/*   state 0 is idle */
/*   states 1 thru 15 are shifing bits */
/*   state 16 is last bit shifted, IRQ set, BSY cleared, FIN set */

   STCLK = (PHI2 & !ECE) # (EXTC & ECE);

  [st0..4].ck = STCLK;
  [st0..4].ar = !RES # SRES # !BSY;
  st0.t = 'b'1;
  st1.t = st0;
  st2.t = st0 & st1;
  st3.t = st0 & st1 & st2;
  st4.t = st0 & st1 & st2 & st3;

/* Define the SCLK pin */
  SCLK = st0 $ CPOL;

